#!/bin/bash
#
# Pre-commit hook for EdTech compliance
# Blocks commits containing secrets, credentials, or PII patterns
#

set -e

RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

echo "ğŸ”’ Running security checks..."

# Get staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$STAGED_FILES" ]; then
    echo -e "${GREEN}âœ“ No files to check${NC}"
    exit 0
fi

FAILED=0

# =============================================================================
# SECRET PATTERNS
# =============================================================================

SECRET_PATTERNS=(
    # AWS
    'AKIA[0-9A-Z]{16}'
    'aws_secret_access_key\s*=\s*['\''"][^'\''"]+['\''"]'
    'aws_access_key_id\s*=\s*['\''"][^'\''"]+['\''"]'

    # API Keys (generic)
    '[aA][pP][iI][-_]?[kK][eE][yY]\s*[:=]\s*['\''"][^'\''"]{20,}['\''"]'
    '[sS][eE][cC][rR][eE][tT][-_]?[kK][eE][yY]\s*[:=]\s*['\''"][^'\''"]{20,}['\''"]'

    # Private Keys
    '-----BEGIN (RSA |DSA |EC |OPENSSH )?PRIVATE KEY-----'
    '-----BEGIN PGP PRIVATE KEY BLOCK-----'

    # JWT/Bearer tokens
    'eyJ[a-zA-Z0-9_-]*\.eyJ[a-zA-Z0-9_-]*\.[a-zA-Z0-9_-]*'
    '[bB][eE][aA][rR][eE][rR]\s+[a-zA-Z0-9_\-\.]+\.[a-zA-Z0-9_\-\.]+\.[a-zA-Z0-9_\-\.]+'

    # GitHub tokens
    'ghp_[a-zA-Z0-9]{36}'
    'gho_[a-zA-Z0-9]{36}'
    'ghu_[a-zA-Z0-9]{36}'
    'ghs_[a-zA-Z0-9]{36}'
    'ghr_[a-zA-Z0-9]{36}'

    # Slack tokens
    'xox[baprs]-[0-9a-zA-Z]{10,48}'

    # Database connection strings with passwords
    '(mongodb|mysql|postgresql|postgres|redis):\/\/[^:]+:[^@]+@'
    'password\s*[:=]\s*['\''"][^'\''"]+['\''"]'
    'pwd\s*[:=]\s*['\''"][^'\''"]+['\''"]'

    # Azure
    'AccountKey=[a-zA-Z0-9+/=]{86}=='

    # Google
    'AIza[0-9A-Za-z\-_]{35}'

    # Stripe
    'sk_live_[0-9a-zA-Z]{24}'
    'rk_live_[0-9a-zA-Z]{24}'

    # SendGrid
    'SG\.[a-zA-Z0-9_-]{22}\.[a-zA-Z0-9_-]{43}'

    # Twilio
    'SK[a-f0-9]{32}'

    # npm tokens
    'npm_[a-zA-Z0-9]{36}'
)

echo "  Checking for secrets..."
for FILE in $STAGED_FILES; do
    if [[ ! -f "$FILE" ]]; then
        continue
    fi

    # Skip binary files and common non-code files
    if file "$FILE" | grep -q "binary"; then
        continue
    fi

    # Skip lock files and generated files
    if [[ "$FILE" =~ \.(lock|sum|min\.js|min\.css)$ ]]; then
        continue
    fi

    for PATTERN in "${SECRET_PATTERNS[@]}"; do
        if git diff --cached "$FILE" | grep -E "$PATTERN" > /dev/null 2>&1; then
            echo -e "${RED}âœ— Potential secret found in: $FILE${NC}"
            echo -e "${YELLOW}  Pattern: $PATTERN${NC}"
            FAILED=1
        fi
    done
done

# =============================================================================
# PII PATTERNS (EdTech Specific)
# =============================================================================

PII_PATTERNS=(
    # SSN patterns
    '\b[0-9]{3}-[0-9]{2}-[0-9]{4}\b'
    '\b[0-9]{9}\b'  # Unformatted SSN

    # Student ID patterns (common formats) - check in log statements
    'log.*student.*id.*[0-9]{5,}'

    # Email in log statements (PII leak)
    'log.*(info|debug|warn|error|trace).*@.*\.(com|edu|org|net)'
    'console\.(log|warn|error).*@.*\.(com|edu|org|net)'

    # DOB patterns
    'dateOfBirth|date_of_birth|dob|birthdate|birth_date'

    # Grade/IEP references in logs
    'log.*(grade|iep|disciplin|suspension)'
)

echo "  Checking for PII patterns..."
for FILE in $STAGED_FILES; do
    if [[ ! -f "$FILE" ]]; then
        continue
    fi

    # Only check code files
    if [[ ! "$FILE" =~ \.(java|ts|tsx|js|jsx|cs|py|rb|go|vue|svelte)$ ]]; then
        continue
    fi

    for PATTERN in "${PII_PATTERNS[@]}"; do
        if git diff --cached "$FILE" | grep -iE "$PATTERN" > /dev/null 2>&1; then
            echo -e "${YELLOW}âš  Potential PII pattern in: $FILE${NC}"
            echo -e "${YELLOW}  Pattern: $PATTERN${NC}"
            echo -e "${YELLOW}  Please verify this is not logging student data${NC}"
            # Don't fail, just warn - could be legitimate
        fi
    done
done

# =============================================================================
# SECURITY ANTI-PATTERNS
# =============================================================================

SECURITY_ANTIPATTERNS=(
    # SQL Injection risks
    'execute\s*\(\s*["\x27].*\+.*["\x27]\s*\)'
    'query\s*\(\s*["\x27].*\+.*["\x27]\s*\)'
    'raw\s*\(\s*["\x27].*\$\{.*\}.*["\x27]\s*\)'

    # Disabled security
    'verify\s*=\s*False'
    'ssl\s*=\s*false'
    'CURLOPT_SSL_VERIFYPEER.*false'
    '@SuppressWarnings.*security'

    # Hardcoded credentials
    'admin:admin'
    'root:root'
    'test:test'
    'password123'

    # Debug/console in production
    'debugger;'
    'console\.log\s*\('
)

echo "  Checking for security anti-patterns..."
for FILE in $STAGED_FILES; do
    if [[ ! -f "$FILE" ]]; then
        continue
    fi

    # Only check code files
    if [[ ! "$FILE" =~ \.(java|ts|tsx|js|jsx|cs|py|rb|go|vue|svelte)$ ]]; then
        continue
    fi

    for PATTERN in "${SECURITY_ANTIPATTERNS[@]}"; do
        if git diff --cached "$FILE" | grep -E "$PATTERN" > /dev/null 2>&1; then
            echo -e "${YELLOW}âš  Security anti-pattern in: $FILE${NC}"
            echo -e "${YELLOW}  Pattern: $PATTERN${NC}"
            # Warn but don't fail - could be test code
        fi
    done
done

# =============================================================================
# FILE TYPE CHECKS
# =============================================================================

echo "  Checking for dangerous file types..."
DANGEROUS_FILES=(
    '.env'
    '.env.local'
    '.env.production'
    'credentials.json'
    'service-account.json'
    'secrets.yml'
    'secrets.yaml'
    '*.pem'
    '*.key'
    '*.p12'
    '*.pfx'
)

for FILE in $STAGED_FILES; do
    BASENAME=$(basename "$FILE")
    for DANGEROUS in "${DANGEROUS_FILES[@]}"; do
        if [[ "$BASENAME" == $DANGEROUS ]] || [[ "$FILE" == *"$DANGEROUS" ]]; then
            echo -e "${RED}âœ— Dangerous file type: $FILE${NC}"
            echo -e "${YELLOW}  These files should not be committed${NC}"
            FAILED=1
        fi
    done
done

# =============================================================================
# RESULTS
# =============================================================================

echo ""
if [ $FAILED -ne 0 ]; then
    echo -e "${RED}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${RED}â•‘              COMMIT BLOCKED - Security Issues Found          â•‘${NC}"
    echo -e "${RED}â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£${NC}"
    echo -e "${RED}â•‘                                                              â•‘${NC}"
    echo -e "${RED}â•‘  Please fix the issues above before committing.              â•‘${NC}"
    echo -e "${RED}â•‘                                                              â•‘${NC}"
    echo -e "${RED}â•‘  To bypass (NOT RECOMMENDED):                                â•‘${NC}"
    echo -e "${RED}â•‘    git commit --no-verify                                    â•‘${NC}"
    echo -e "${RED}â•‘                                                              â•‘${NC}"
    echo -e "${RED}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    exit 1
else
    echo -e "${GREEN}âœ“ Security checks passed${NC}"
    exit 0
fi
